!>
................................................................................
.    Copyright (c) 2009-2024 Crater Dog Technologies.  All Rights Reserved.    .
................................................................................
.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.               .
.                                                                              .
.  This code is free software; you can redistribute it and/or modify it under  .
.  the terms of The MIT License (MIT), as published by the Open Source         .
.  Initiative. (See https://opensource.org/license/MIT)                        .
................................................................................
<!

!>
CRATER DOG SYNTAX NOTATION
This document contains a formal definition of the Crater Dog Syntax Notationâ„¢
(CDSN) using CDSN itself in homage to Douglas Hofstadter.

A language syntax consists of a set of rule definitions and token definitions.

The following intrinsic character types are context specific:
 * ANY - Any language specific character.
 * LOWER - Any language specific lowercase character.
 * UPPER - Any language specific uppercase character.
 * DIGIT - Any language specific digit.
 * ESCAPE - Any environment specific escape sequence.
 * CONTROL - Any environment specific (non-printable) control character.
 * EOL - The environment specific end-of-line character.
 * EOF - The environment specific end-of-file marker (pseudo character).

A predicate may be constrained by any of the following cardinalities:
 * predicate{M} - Exactly M instances of the specified predicate.
 * predicate{M..} - M or more instances of the specified predicate.
 * predicate{M..N} - M to N instances of the specified predicate.
 * predicate? - Zero or one instances of the specified predicate.
 * predicate* - Zero or more instances of the specified predicate.
 * predicate+ - One or more instances of the specified predicate.

An inversion "~" within a definition may only be applied to an intrinsic
character type or a glyph range.
<!

!>
RULE DEFINITIONS
The following rules are used by the parser when parsing the stream of tokens
generated by the scanner.  Each rule name begins with an uppercase letter.  The
rule definitions may specify the names of tokens or other rules and are matched
by the parser in the order listed.  A rule definition may also be directly or
indirectly recursive.  The sequence of factors within in a rule definition may
be separated by spaces which are ignored by the parser.
<!
AST: Syntax EOL* EOF  ! Terminated with an end-of-file marker.

Syntax: Header+ Definition+

Header: comment EOL+

Definition: (comment EOL)? name ":" Expression EOL+

Expression: Inline | Multiline

Inline: Alternative ("|" Alternative)* note?

Multiline: Line+

Line: EOL Alternative note?

Alternative: Factor+

Factor: Predicate Cardinality?  ! The default cardinality is one.

Predicate: Atom | Element | Filter | Precedence

Atom: Glyph | intrinsic

Glyph: character (".." character)?  ! The range of characters is inclusive.

Element: literal | name

Filter: "~"? "[" Atom+ "]"

Precedence: "(" Expression EOL? ")"

Cardinality:
    "?"  ! Zero or one instance of a predicate.
    "*"  ! Zero or more instances of a predicate.
    "+"  ! One or more instances of a predicate.
    "{" Constraint "}"  ! Constrains the number of instances of a predicate.

Constraint: number (".." number?)?  ! The range of numbers is inclusive.

!>
TOKEN DEFINITIONS
The following token definitions are used by the scanner to generate the stream
of tokens that are processed by the parser.  Each token name begins with a
lowercase letter.  Unlike with rule definitions, a token definition cannot
specify the name of a rule within its definition but it can specify the name of
other tokens.  Token definitions cannot be recursive and the scanning of tokens
is NOT greedy.  Any spaces within a token definition are NOT ignored.
<!
character: "'" ~[CONTROL] "'"  ! Any printable single character.

comment: "!>" EOL ANY* EOL "<!"  ! Chooses the shortest possible match.

delimiter:
    "~"
    "?"
    "*"
    "+"
    ":"
    "|"
    "("
    ")"
    "["
    "]"
    "{"
    "}"
    ".."

intrinsic:
    "ANY"
    "LOWER"
    "UPPER"
    "DIGIT"
    "ESCAPE"
    "CONTROL"
    "EOL"
    "EOF"

letter: [LOWER UPPER]

literal: '"' (ESCAPE | ~['"' CONTROL])+ '"'

name: letter (letter | DIGIT)*

note: "! " ~[CONTROL]*

number: DIGIT+

