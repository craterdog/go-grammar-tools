!>
................................................................................
.    Copyright (c) 2009-2024 Crater Dog Technologies.  All Rights Reserved.    .
................................................................................
.  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.               .
.                                                                              .
.  This code is free software; you can redistribute it and/or modify it under  .
.  the terms of The MIT License (MIT), as published by the Open Source         .
.  Initiative. (See https://opensource.org/license/MIT)                        .
................................................................................
<!

!>
CRATER DOG SYNTAX NOTATION
This document contains a formal definition of the Crater Dog Syntax Notation™
(CDSN) using CDSN itself in homage to Douglas Hofstadter.

A language syntax consists of a set of rule definitions and expression patterns.

The following intrinsic character types are context specific:
 * ANY - Any language specific character.
 * LOWER - Any language specific lowercase character.
 * UPPER - Any language specific uppercase character.
 * DIGIT - Any language specific digit.
 * ESCAPE - Any environment specific escape sequence.
 * CONTROL - Any environment specific (non-printable) control character.
 * EOL - The environment specific end-of-line character.
 * EOF - The environment specific end-of-file marker (pseudo character).

A predicate may be constrained by any of the following cardinalities:
 * predicate{M} - Exactly M instances of the specified predicate.
 * predicate{M..N} - M to N instances of the specified predicate.
 * predicate{M..} - M or more instances of the specified predicate.
 * predicate? - Zero or one instances of the specified predicate.
 * predicate* - Zero or more instances of the specified predicate.
 * predicate+ - One or more instances of the specified predicate.

A negation "~" within a regular expression pattern may only be applied to a
bounded range of possible intrinsic character types or printable unicode
characters called runes.
<!

!>
RULE DEFINITIONS
The following rules are used by the parser when parsing the stream of tokens
generated by the scanner based on the expression patterns.  Each rule name
begins with an uppercase letter.  The rule definitions may specify the names of
expressions or other rules and are matched by the parser in the order listed.  A
rule definition may also be directly or indirectly recursive.  The parsing of
tokens is greedy and will match as many repeated token types as possible. The
sequence of factors within in a rule definition may be separated by spaces which
are ignored by the parser.
<!
Syntax: Header+ Rule+ Expression+ EOL* EOF  ! Terminated with an end-of-file marker.

Header: comment EOL

Rule: comment? uppercase ":" Definition EOL+

Definition:
    Inlined
    Multilined

Inlined: Factor+ note?

Multilined: Line+

Line: EOL Identifier note?

Identifier:
    lowercase
    uppercase

Factor: Predicate Cardinality?  ! The default cardinality is one.

Predicate:
    literal
    lowercase
    uppercase
    intrinsic

Cardinality:
    Constrained
    quantified

Constrained: "{" number Limit? "}"  ! A constrained range of numbers is inclusive.

Limit: ".." number?

Expression: comment? lowercase ":" Pattern note? EOL+

Pattern: Part+ Alternative*

Part: Element Cardinality?  ! The default cardinality is one.

Alternative: "|" Part+

Element:
    Grouped
    Filtered
    String

Grouped: "(" Pattern ")"

Filtered: negation? "[" Character+ "]"

String:
    rune
    literal
    lowercase
    intrinsic

Character:
    Bounded
    intrinsic

Bounded: rune Extent?  ! A bounded range of runes is inclusive.

Extent: ".." rune

!>
REGULAR EXPRESSION PATTERNS
The following regular expression patterns are used by the scanner to generate
a stream of tokens—each a match of a regular expression—that are to be processed
by the parser.  Each regular expression name begins with a lowercase letter.
Unlike rule definitions, a regular expression pattern cannot specify the name of
a rule within its pattern—but it may specify the name of another regular
expression.  Regular expression patterns cannot be recursive and the scanning of
patterns is NOT greedy.  Any spaces within a regular expression pattern are part
of the regular expression and are NOT ignored.
<!
comment: "!>" EOL ANY* EOL "<!" EOL  ! Chooses the shortest possible match.

delimiter: ":" | "|" | "(" | ")" | "[" | "]" | "{" | "}" | ".."

intrinsic: "ANY" | "LOWER" | "UPPER" | "DIGIT" | "ESCAPE" | "CONTROL" | "EOL" | "EOF"

letter: [LOWER UPPER]

literal: '"' (ESCAPE | ~['"' CONTROL])+ '"'

lowercase: LOWER (letter | DIGIT)*

negation: "~"

note: "! " ~[CONTROL]*

number: DIGIT+

quantified: "?" | "*" | "+"

rune: "'" ~[CONTROL] "'"  ! Any printable unicode character.

uppercase: UPPER (letter | DIGIT)*

